<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

<script>
    /*
    https://leetcode-cn.com/problems/rectangle-overlap/submissions/
    矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
    如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
    给出两个矩形，判断它们是否重叠并返回结果。
     */
    var abs = Math.abs;
    var max = Math.max;
    var min = Math.min;
    var rec1 = [0, 0, 2, 2],
        rec2 = [1, 1, 3, 3], //true
        rec3 = [0, 0, 1, 1],
        rec4 = [1, 0, 2, 1], //false
        rec5 = [5, 15, 8, 18],
        rec6 = [0, 3, 7, 9]; //false
    var isRectangleOverlap1 = function (rec1, rec2) {
        // 对每种情况分开判断显然很复杂，另辟蹊径
        if (max(rec1[0], rec2[0]) < min(rec1[2], rec2[2])) {
            if (max(rec1[1], rec2[1]) < min(rec1[3], rec2[3])) {
                return true
            } else {
                return false;
            }
        } else {
            return false;
        }
    };

    // isRectangleOverlap2优于isRectangleOverlap1，其用时更少
    var isRectangleOverlap2 = function (rec1, rec2) {
        // 判断不重叠的情况似乎更加简单
        if (rec1[2] <= rec2[0] || rec1[0] >= rec2[2]) {
            return false;
        } else {
            if (rec1[3] <= rec2[1] || rec2[3] <= rec1[1]) {
                return false;
            } else {
                return true;
            }
        }
    };

    // 可以算出面积，三种方法中此方法用时最多，且内存消耗也多
    var isRectangleOverlap3 = function (rec1, rec2) {
        if (rec1[2] <= rec2[0] || rec2[2] <= rec1[0] || rec1[3] <= rec2[1] || rec2[3] <= rec1[1]) {
            return false;
        } else {
            var area = (abs(min(rec1[3], rec2[3]) - max(rec1[1], rec2[1]))) *
                (abs(min(rec1[2], rec2[2]) - max(rec1[0], rec2[0])));
            console.log("重叠面积为：" + area);
            return new Boolean(area);
        }
    };

    // 此方法用时最短，为什么？其语句看起来多，实际上只用了最简单的循环和判断
    var isRectangleOverlap4 = function (rec1, rec2) {
        if (rec1[0] >= rec2[2] || rec1[2] <= rec2[0] || rec1[1] >= rec2[3] || rec1[3] <= rec2[1]) {
            return false
        }
        return true;
    };

    console.log("isRectangleOverlap1：" + isRectangleOverlap1(rec1, rec2));
    console.log("isRectangleOverlap2：" + isRectangleOverlap2(rec1, rec2));
    console.log("isRectangleOverlap3：" + isRectangleOverlap3(rec1, rec2));
    console.log("isRectangleOverlap1：" + isRectangleOverlap1(rec3, rec4));
    console.log("isRectangleOverlap2：" + isRectangleOverlap2(rec3, rec4));
    console.log("isRectangleOverlap3：" + isRectangleOverlap3(rec3, rec4));
    console.log("isRectangleOverlap1：" + isRectangleOverlap1(rec5, rec6));
    console.log("isRectangleOverlap2：" + isRectangleOverlap2(rec5, rec6));
    console.log("isRectangleOverlap3：" + isRectangleOverlap3(rec5, rec6));

</script>
<script>
    // 矩形面积
    // https://leetcode-cn.com/problems/rectangle-area/
    var computeArea1 = function (A, B, C, D, E, F, G, H) {
        var min = Math.min,
            max = Math.max,
            abs = Math.abs;
        // 需要考虑没有重叠和有重叠的情况
        if (C <= E || A >= G) {
            return ((D - B) * (C - A) + (H - F) * (G - E));
        } else {
            if (D <= F || H <= B) {
                return ((D - B) * (C - A) + (H - F) * (G - E));
            } else {
                return ((D - B) * (C - A) + (H - F) * (G - E) - abs((min(D, H) - max(B, F)) * (min(C, G) -
                    max(A,
                        E))));
            }
        }
    };

    var computeArea2 = function (A, B, C, D, E, F, G, H) {
        const sum = (C - A) * (D - B) + (G - E) * (H - F);
        const minX1 = Math.max(A, E);
        const minX2 = Math.min(C, G);
        if (minX2 <= minX1) return sum;
        const minY1 = Math.max(B, F);
        const minY2 = Math.min(D, H);
        if (minY2 <= minY1) return sum;
        return sum - (minX2 - minX1) * (minY2 - minY1);
    };

    var computeArea3 = function (A, B, C, D, E, F, G, H) {
        var coverRecXLen = (C - A + G - E - (G > C ? G : C) + (A < E ? A : E)) //重合矩形宽度
        var coverRecYLen = (D - B + H - F - (D > H ? D : H) + (B < F ? B : F)) //重合矩形高度
        return (C - A) * (D - B) + (G - E) * (H - F) -
            (coverRecXLen > 0 && coverRecYLen > 0 ? coverRecXLen * coverRecYLen : 0) //有重合则减去重合面积
    };

    console.log("computeArea1：" + computeArea1(-2, -2, 2, 2, 3, 3, 4, 4));
    console.log("computeArea2：" + computeArea2(-2, -2, 2, 2, 3, 3, 4, 4));
    console.log("computeArea3：" + computeArea3(-2, -2, 2, 2, 3, 3, 4, 4));

</script>
<script>
    // https://leetcode-cn.com/problems/basic-calculator/
    // 实现一个基本的计算器来计算一个简单的字符串表达式的值。
    // 字符串表达式可以包含左括号(，右括号)， 加号 + ，减号 - ，非负整数和空格。
    // calculate("1 + 1");

    var calculate2 = function (s) {
        let arr = [],
            temp = '';
        for (let i = 0; i < s.length; i++) {
            temp = s[i];

            if (temp == ' ') //空格
                continue;
            else if (temp >= '0' && temp <= '9') { //数字，碰到数字往前计算
                while (s[i + 1] >= '0' && s[i + 1] <= '9' && i < s.length - 1) {
                    temp += s[i + 1];
                    i++;
                }
                arr.push(temp);
                getResult(arr);
            } else { //其他左右括号，和+-号
                arr.push(temp);

                if (temp == ')') { //碰到右括号往前计算
                    getResult(arr);
                }
            }
        }
        return arr.length == 1 ? arr[0] : 0;
    }

    //从栈顶往栈底计算
    function getResult(arr) { //arr为字符串数组
        while (true) {
            if (arr.length < 2) break;

            let last = arr.pop();

            if (last == ')') {
                let last_p = parseInt(arr.pop()),
                    last_p_p = arr.pop();

                if (last_p_p == "(") {
                    arr.push(last_p);
                } else { //+ 或 -
                    let num = parseInt(arr.pop());
                    arr.push(last_p_p == "+" ? num + last_p : num - last_p);
                    arr.push(")")
                }
            } else { //last为数字
                let last_p = arr.pop();

                if (last_p == "(") { //停止循环
                    arr.push("(");
                    arr.push(last);
                    break;
                } else { //last_p 为 + 或 -
                    last = parseInt(last);
                    let num = parseInt(arr.pop())
                    arr.push(last_p == "+" ? num + last : num - last);
                }
            }
        }
    }
    console.log(calculate2("(1+(4+5+2)-3)+(6+8)"));

</script>

</html>
